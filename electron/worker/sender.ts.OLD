import pkg from 'whatsapp-web.js';
const { MessageMedia } = pkg;
import type { Client } from 'whatsapp-web.js';
import * as fs from 'fs';
import * as path from 'path';

export interface SendResult {
  success: boolean;
  messageId?: string;
  error?: string;
  timestamp: number;
}

export interface MediaFile {
  path: string;
  caption?: string;
  filename?: string;
}

const MAX_MEDIA_FILES = 10;
const MAX_TEXT_LENGTH = 4096;

export async function sendText(
  client: Client,
  phoneNumber: string,
  text: string
): Promise<SendResult> {
  const startTime = Date.now();

  try {
    if (!text || text.trim().length === 0) {
      throw new Error('Message text cannot be empty');
    }

    if (text.length > MAX_TEXT_LENGTH) {
      throw new Error(`Message text exceeds maximum length of ${MAX_TEXT_LENGTH} characters`);
    }

    const formattedNumber = formatPhoneNumber(phoneNumber);
    const chatId = `${formattedNumber}@c.us`;

    const message = await client.sendMessage(chatId, text);

    return {
      success: true,
      messageId: message.id.id,
      timestamp: Date.now() - startTime,
    };
  } catch (error: any) {
    console.error('[Sender] Error sending text:', error);
    return {
      success: false,
      error: error.message || 'Unknown error sending text message',
      timestamp: Date.now() - startTime,
    };
  }
}

export async function sendMedia(
  client: Client,
  phoneNumber: string,
  mediaPath: string,
  caption?: string
): Promise<SendResult> {
  const startTime = Date.now();

  try {
    if (!fs.existsSync(mediaPath)) {
      throw new Error(`Media file not found: ${mediaPath}`);
    }

    const stats = fs.statSync(mediaPath);
    if (stats.size === 0) {
      throw new Error('Media file is empty');
    }

    if (stats.size > 100 * 1024 * 1024) {
      throw new Error('Media file too large (max 100MB)');
    }

    const formattedNumber = formatPhoneNumber(phoneNumber);
    const chatId = `${formattedNumber}@c.us`;

    const media = MessageMedia.fromFilePath(mediaPath);

    const options: any = {};
    if (caption) {
      options.caption = caption;
    }

    const message = await client.sendMessage(chatId, media, options);

    return {
      success: true,
      messageId: message.id.id,
      timestamp: Date.now() - startTime,
    };
  } catch (error: any) {
    console.error('[Sender] Error sending media:', error);
    return {
      success: false,
      error: error.message || 'Unknown error sending media',
      timestamp: Date.now() - startTime,
    };
  }
}

export async function sendMultipleMedia(
  client: Client,
  phoneNumber: string,
  mediaFiles: MediaFile[]
): Promise<SendResult[]> {
  if (mediaFiles.length > MAX_MEDIA_FILES) {
    throw new Error(`Cannot send more than ${MAX_MEDIA_FILES} media files at once`);
  }

  const results: SendResult[] = [];

  for (const mediaFile of mediaFiles) {
    const result = await sendMedia(client, phoneNumber, mediaFile.path, mediaFile.caption);
    results.push(result);

    if (!result.success) {
      break;
    }

    await sleep(2000);
  }

  return results;
}

export function personalizeMessage(
  template: string,
  variables: Record<string, string>,
  contactName?: string,
  contactPhone?: string
): string {
  if (!template) return '';

  // Use a replacer function for all {{variable}} patterns
  return template.replace(/\{\{\s*([^}]+)\s*\}\}/g, (_match, key) => {
    const varName = key.trim().toLowerCase();

    // Handle standard fields
    if (varName === 'name') return contactName || '';
    if (varName === 'phone' || varName === 'mobile') return contactPhone || '';

    // Handle v1-v10 and other custom variables
    const value = variables[key.trim()] || variables[varName];
    return value !== undefined ? value : '';
  });
}

export function formatPhoneNumber(phone: string): string {
  let cleaned = phone.replace(/\D/g, '');

  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }

  if (!cleaned.startsWith('91') && cleaned.length === 10) {
    cleaned = '91' + cleaned;
  }

  return cleaned;
}

export function validatePhoneNumber(phone: string): boolean {
  const formatted = formatPhoneNumber(phone);
  return formatted.length >= 10 && formatted.length <= 15;
}

export async function checkNumberRegistered(
  client: Client,
  phoneNumber: string
): Promise<boolean> {
  try {
    const formattedNumber = formatPhoneNumber(phoneNumber);
    const chatId = `${formattedNumber}@c.us`;
    const isRegistered = await client.isRegisteredUser(chatId);
    return isRegistered;
  } catch (error) {
    console.error('[Sender] Error checking if number is registered:', error);
    return false;
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export function extractMediaInfo(mediaPath: string): {
  type: 'image' | 'video' | 'audio' | 'document';
  mimeType: string;
  size: number;
} {
  const ext = path.extname(mediaPath).toLowerCase();
  const stats = fs.statSync(mediaPath);

  let type: 'image' | 'video' | 'audio' | 'document';
  let mimeType: string;

  const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
  const videoExts = ['.mp4', '.avi', '.mov', '.mkv', '.webm'];
  const audioExts = ['.mp3', '.wav', '.ogg', '.m4a', '.opus'];

  if (imageExts.includes(ext)) {
    type = 'image';
    mimeType = `image/${ext.substring(1)}`;
  } else if (videoExts.includes(ext)) {
    type = 'video';
    mimeType = `video/${ext.substring(1)}`;
  } else if (audioExts.includes(ext)) {
    type = 'audio';
    mimeType = `audio/${ext.substring(1)}`;
  } else {
    type = 'document';
    mimeType = 'application/octet-stream';
  }

  return {
    type,
    mimeType,
    size: stats.size,
  };
}
