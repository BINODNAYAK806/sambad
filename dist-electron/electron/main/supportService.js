import * as crypto from 'crypto';
// Use a fixed secret for this application instance. 
// In a real production app, this might be more obscured or environment-based,
// but for this implementation, a hardcoded secret in main process is acceptable per plan.
const APP_SECRET = 'SAMBAD_CAMPAIGN_MANAGER_SECURE_UNLOCK_KEY_2025';
// Store current challenges in memory to verify they were generated by us
// Map<ChallengeCode, Timestamp>
const activeChallenges = new Map();
// Clean up old challenges every hour
setInterval(() => {
    const now = Date.now();
    for (const [code, timestamp] of activeChallenges.entries()) {
        if (now - timestamp > 3600000) { // 1 hour expiration
            activeChallenges.delete(code);
        }
    }
}, 3600000);
/**
 * Generates a short, readable random code (e.g., "REQ-A1B2")
 */
export function generateChallenge() {
    const randomBytes = crypto.randomBytes(4);
    const code = 'REQ-' + randomBytes.toString('hex').toUpperCase().substring(0, 4);
    // Store valid challenge with timestamp
    activeChallenges.set(code, Date.now());
    return code;
}
/**
 * Verifies if the provided response key matches the challenge using HMAC
 */
export function verifySupportCode(challenge, response) {
    if (!challenge || !response)
        return false;
    // 1. Verify challenge exists and is recent (prevent replay of very old codes if logic changes)
    if (!activeChallenges.has(challenge)) {
        // We might allow verifying even if not in map for statelessness if needed,
        // but checking map prevents users from just using any string as challenge.
        // However, for the tool to work simpler, we can relax this if needed.
        // Let's stick to strict map check for security.
        return false;
    }
    // 2. Generate expected response
    // Logic: HMAC-SHA256(challenge, APP_SECRET) -> truncated to 8 chars or similar
    const hmac = crypto.createHmac('sha256', APP_SECRET);
    hmac.update(challenge);
    const fullHash = hmac.digest('hex').toUpperCase();
    // We use a prefix plus part of the hash as the key
    // e.g., "UNLOCK-" + first 8 chars of hash
    const expectedResponse = 'UNLOCK-' + fullHash.substring(0, 8);
    return response === expectedResponse;
}
/**
 * Helper to get the secret (Only for the generator script, theoretically)
 * In the main app, we just use it internally.
 */
export function getSecret() {
    return APP_SECRET;
}
//# sourceMappingURL=supportService.js.map